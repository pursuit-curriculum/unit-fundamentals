# Programming Principles

## Learning Objectives

By the end of this lesson, you should be able to:

- Define the KISS and YAGNI acronyms and how they apply to programming.
- Define the principle of least astonishment.
- Describe what the happy path refers to in programming and why it is useful to focus on first.

---

## Guiding questions

- Why do programming conventions matter, and how can they benefit both the coder and other developers working on the code in the future?

- What are some key coding conventions mentioned in the reading, and why is it important to follow them?

- Explain the KISS principle. Provide an example from previous code you've seen or written that demonstrates how keeping code simple can enhance readability.

- What does the YAGNI principle advise, and why is it essential to avoid adding unnecessary functionality to your code?

- What is the "Principle of Least Astonishment," and why is it important to write code that behaves predictably and intuitively?

- In the reading, there's a code example that demonstrates surprising behavior in JavaScript. Why is it crucial to avoid such unexpected outcomes in your code?

- What is meant by "starting with the happy path" in programming? How does this approach help simplify development and debugging?

- In the reading, there's a function named `pluckNames()` that focuses on the happy path first. Why is this approach effective, and how does it benefit the development process?

- Can you think of any real-world examples where failing to follow the programming principles discussed in this reading might lead to issues in software development?

- How would you explain these programming principles to someone who is new to coding? What analogies or metaphors might help them grasp these concepts better?

- In your own coding experiences, have you encountered situations where adhering to these principles made a significant difference in the quality of your code? Share some anecdotes.

- Do you believe there are exceptions to these principles? Are there situations in which complexity, additional functionality, or surprising behavior might be justified in code? Discuss.
