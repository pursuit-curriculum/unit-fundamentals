# Binary Search

## Learning Objectives

By the end of this lesson, you should be able to:

- Build a binary search algorithm.
- Identify the Big O of binary search and describe why it is so efficient.
- Identify situations where binary search can be applied to solve a problem.

---

## Guiding questions

- Can you explain the fundamental steps involved in building a binary search algorithm? Are there any key considerations in implementing this algorithm?

- What is the Big O notation used to express the time complexity of binary search, and why is it described as "logarithmic time"?

- Can you provide an example of how O(log n) is calculated for binary search? How does the number of iterations change as the size of the dataset (n) grows?

- In what practical scenarios or applications can binary search be beneficial? Can you think of examples beyond those mentioned in the reading?

- Are there limitations or constraints when applying binary search to problem-solving? What types of datasets or situations are not suitable for binary search?

- Explain the concept of a "sorted array" and why it's a prerequisite for binary search to work effectively.

- How does binary search handle duplicate values in an array, and what considerations should be made if the dataset contains duplicate elements?

- In your own words, summarize the key takeaways from this chapter and explain why understanding binary search is important in the field of computer science and problem-solving.

- Visit the "Algorithm Example: Binary Search" Replit within your classroom's Replit team. Take a look at the code and the `readme.md` file and then answer the following questions.

  - The `readme.md` includes an introduction followed by 7 sections. Describe the purpose of each section in the `readme.md` file.

    1. Algorithm description

    1. Algorithm representation

    1. JavaScript code walkthrough

    1. Big O Evaluation

    1. Use cases

    1. Edge cases and concerns

    1. Citations

  - What knowledge would someone need to be comfortable with before understanding the `readme.md` file?

  - What does the `readme.md` do well regarding breaking down how the binary search algorithm works? What could it do to improve?

  - Is there anything you think is missing from the explanation in the `readme.md` file that is critical for understanding how binary search works?
